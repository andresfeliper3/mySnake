<head>
  <style>
    @font-face {
    font-family: 'Retro Gaming';
    src: url('RetroGaming.woff2') format('woff2'),
        url('RetroGaming.woff') format('woff'),
        url('RetroGaming.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
}
    </style>
    
</head>
<canvas id="canvas" width="500" height="500"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/buzz.min.js"></script>
<script src="web-lib/functional-light.js"></script>
<script>
  //Vamos a usar http://processingjs.org/

let x= 0;
  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;
  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  } 
  //FUNCIONES
  /*pop:list->list
Quita el último elemento de una lista
pop([1,2,3])->[1,2]
pop([4,0,5,9,7])->[4,0,5,9]
*/
function pop(list) {
    if(length(list)==1) {
        return [];
    } else {
        return cons(first(list),pop(rest(list)));
    }
}
function distance(x1,y1,x2,y2) // función que determina la distancia que hay entre dos coordenadas
{
  return Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2));
}
//hace que la bala del snake  cambie en el eje x
function changeBulletsX(world,ax)
{
  if (world.shooting)//si shooting es true 
  {
    return world.bullets.x + world.fixedSnake.x// movimiento de la bala del snake en el eje x
  }
  else{
    return world.snake[0].x + ax // reposicionamiento de la bala en la cabeza del snake
  }
}

// //hace que la bala del snake  cambie en el eje y
function changeBulletsY(world,ay)
{
  if (world.shooting)//si shooting es true 
  {
    return world.bullets.y + world.fixedSnake.y // movimiento de la bala del snake en el eje y
  }
  else{
    return world.snake[0].y + ay // reposicionamiento de la bala en la cabeza del snake
  }
}

// cambia la dirección de la bala del ovni
function changeFixed(world)
{
  if(world.shootingOvni)// si shooting es true
  {
    if (world.snake[0].y <= 250 && world.ammo.y == 250) // si el snake está arriba del ovni y la bala del ovni está en y:250
  {
    return make(world.fixed,{y: -world.ammo.speed})//disparar arriba
  }
  else if(world.snake[0].y>250&&world.ammo.y==250)// si el snake está abajo del ovni y la bala del ovni está en y:250
  {
    return make(world.fixed,{y: world.ammo.speed})//disparar abajo
  }
  else
  {
    return world.fixed //sino entonces sigue disparando en la última dirección registrada
  }
  }
  else
  {
    return make(world.fixed,{x: world.ovni.body[0].x,y: 0})// si no está disparando reposiciona la bala del ovni en la cabeza
  }
}


function changeSnake(world,ax,ay) // movimiento del snake
{ 
  if(world.snake[0].x == world.food.x && world.snake[0].y == world.food.y) {
    return cons({x: world.snake[0].x + ax , y: world.snake[0].y + ay},world.snake); //se mueve y crece
  }
  return cons({x: world.snake[0].x + ax , y: world.snake[0].y + ay},pop(world.snake));// mueve el snake y quita la cola
}

function changeAmmo(world,dx,dy) //reposiciona o dispara la bala
{ 
  if (world.shootingOvni)// si está disparando
  {
    return make(world.ammo,{x: world.ammo.x, y: world.ammo.y + world.fixed.y}); //disparar la bala de ovni
  }
  else
  {
    return make(world.ammo,{x: world.ovni.body[0].x + dx, y: world.ovni.body[0].y + dy});//reposicionar la bala del ovni
  }
}

function changebody(world)//movimiento del ovni
{
  if(world.score >= score1){
    world.sound.stop();
    world.soundBattle.play();
  return cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body));
  } else {
    return world.ovni.body;
  }
}


function changeOvniDirection(world)//cambia la dirección del ovni al alcanzar los límites del canvas
{
  if (world.ovni.body[0].x >= 420)
  {
    return -10
  }
  else if(world.ovni.body[0].x <= 0)
  {
    return 10
  }
  else{
    return world.ovniDirection
  }
}


function changeShooting(world)//
{  // si las balas del snake están dentro del canvas
  if(world.bullets.x > world.ovni.body[0].x && world.bullets.x < world.ovni.body[0].x +70 &&
     world.bullets.y > world.ovni.body[0].y && world.bullets.y < world.ovni.body[0].y+60){
    return false;

  }
  else if((world.bullets.x <= 500 && world.bullets.x >=0) && (world.bullets.y <=500 && world.bullets.y >= 0))
  {
    return world.shooting
  }else
  {
    return false;
  }
}


function changeShootingOvni(world){
  //si las balas del ovni están dentro del canvas
  if((world.ammo.x <= 500 && world.ammo.x >=0) && (world.ammo.y <=500 && world.ammo.y >= 0))
  {
    return true;
  }
  else
  {
    return false;
  }
}

function changeScore(world) // si el snake se com una manzana incremente el score
{
  if (first(world.snake).x==world.food.x && first(world.snake).y==world.food.y)
  {
    return world.score+100;
  }
  else
  {
    return world.score;
  }
}

function changeInverse(world){ // cambiar la inversión de las teclas

  if(first(world.snake).x==world.food.x && first(world.snake).y==world.food.y)// restaurar teclas
  {
    return false;
  }
  else if(first(world.snake).x==world.avocado.x && first(world.snake).y==world.avocado.y) //restaurar teclas
  {
    return false;
  }
  else if(first(world.snake).x==world.rottenAvocado.x && first(world.snake).y==world.rottenAvocado.y)// invertir teclas
  {
    return true;
  }
  else
  {
    return world.inverse;
  }
}

function changeBulletsAmount (world) // incrementa las balas del snake si se come una sandía
{
  if(first(world.snake).x==world.watermelon.x && first(world.snake).y==world.watermelon.y)
  {
    return world.bullets.amount + 1
  }
  else{
    return world.bullets.amount
  }
}

function changeFood (world,randomx,randomy) //reposiciona la manzana al comerla
{
  if(first(world.snake).x==world.food.x && first(world.snake).y==world.food.y)
  {
    return make(world.food,{x: randomx,y: randomy});
  }
  else
  {
    return world.food
  }
}

function changeWatermelon(world,randomx,randomy) // reposiciona la sandía al comerla
{
  if(first(world.snake).x==world.watermelon.x && first(world.snake).y==world.watermelon.y)
  {
    return make(world.watermelon,{x: randomx,y: randomy});
  }
  else
  {
    return world.watermelon
  }
}

function changeAvocado(world,randomx,randomy,randomw,randomz)// reposiciona los aguacates al comer el bueno o el malo
{
  if(first(world.snake).x==world.avocado.x && first(world.snake).y==world.avocado.y)
  {   world.soundVida.play();
    return make(world.avocado,{x: randomx,y: randomy})
  }
  else if(first(world.snake).x==world.rottenAvocado.x && first(world.snake).y==world.rottenAvocado.y)
  {
    return make(world.avocado,{x: randomx,y: randomy})
  }
  else
  {
    return world.avocado;
  }
}
function changeRottenAvocado(world,randomx,randomy,randomw,randomz)// reposiciona los aguacates al comer el bueno o el malo
{
  if(first(world.snake).x==world.avocado.x && first(world.snake).y==world.avocado.y)
  {
    return make(world.rottenAvocado,{x: randomw,y: randomz})
  }
  else if(first(world.snake).x==world.rottenAvocado.x && first(world.snake).y==world.rottenAvocado.y)
  {
    return make(world.rottenAvocado,{x: randomw,y: randomz})
  }
  else
  {
    return world.rottenAvocado;
  }
}

function changeSnakeLifes(world) // aumenta una vida al snake al comerse un aguacate bueno
{
  if(first(world.snake).x==world.avocado.x && first(world.snake).y==world.avocado.y)
  {
    return world.snakeLifes + 1
  }
  else
  {
    return world.snakeLifes;
  }
}

function changeFixedSnake(world,ax,ay) // animación de disparo del snake -- dx/dt o dy/dt --velocidad
{
  if(world.bullets.x == world.snake[0].x + ax && world.bullets.y == world.snake[0].y + ay)//si la bala está en la cabeza del snake
  {
    if(ax==0)
    {
      return make(world.fixedSnake, {x: ax})
    }
    else
    {
      return make(world.fixedSnake, {y: ay})
    }
  }
  else
  {
    return world.fixedSnake
  }
}

function changeOvniLives(world,ax,ay){
  if(world.bullets.x > world.ovni.body[0].x && world.bullets.x < world.ovni.body[0].x +70 &&
  world.bullets.y > world.ovni.body[0].y && world.bullets.y < world.ovni.body[0].y+60){ // si la bala está en el rango del ovni
      return world.ovniLives -0.5;
  }else{
      return world.ovniLives
  }
}

function changeNodding(world) {
  if(world.score >= 1000) {
    return true;
  } else {
    return false;
  }
}

function nodding(axisVal, world) {
  if(world.isNodding) {
    return 4 * Math.sin(nodFactor * Math.PI * axisVal);
  } else{
    return 0;
  }
}




/*master
Evalúa condiciones para establecer los cambios y el comportamiento en el mundo
*/
function master(world,ax,ay,randomx,randomy,randomw,randomz) {
  return make(world,{
  snake: changeSnake(world,ax,ay),
  ammo: changeAmmo(world,world.ovniDirection,0),
  avocado: changeAvocado(world,randomx,randomy,randomw,randomz),
  snakeLifes: changeSnakeLifes(world),
  bullets: make(world.bullets,{amount: changeBulletsAmount(world),
                               x: changeBulletsX(world,ax),
                               y: changeBulletsY(world,ay)}),
  food: changeFood(world,randomx,randomy),
  inverse: changeInverse(world),
  ovniDirection: changeOvniDirection(world),
  rottenAvocado: changeRottenAvocado(world,randomx,randomy,randomw,randomz),
  score: changeScore(world),
  shooting: changeShooting(world),
  shootingOvni: changeShootingOvni(world),
  watermelon: changeWatermelon(world,randomx,randomy),
  ovni: make(world.ovni,{body: changebody(world,world.changeOvniDirection,0)}),
  fixed: changeFixed(world),
  fixedSnake: changeFixedSnake(world,ax,ay),
  ovniLives: changeOvniLives(world,ax,ay),
  isNodding: changeNodding(world)
  })
}

  //Dimensiones del juego
  const gameSize = {height:500,width:500};
  //Tamaño de cada segmento del snake
  const size = 10;
  //Aumento del score al comer
  const score1 = 500; 
  //Frecuencia de la oscilación
  const nodFactor = 1/60;
  const mySnake = [{ x: 100, y: 100 }, { x: 90, y: 100 }, { x: 80, y: 100 },{ x:70, y:100}];
  const myLifes = [{ x: 10, y: 460 }, { x: 40, y: 460 }, { x: 70, y: 460 }];
  const myAsteroids = [{x:10,y:-10}];
  const myOvni = {body: [{x:-100,y:250}],
                   // wings:[{x:-10,y:240},{x:-10,y:260}]
                  }
  function sketchProc(processing) {
    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      processing.frameRate(10);
      processing.size(gameSize.width, gameSize.height);
      processing.background(0, 0, 0);
      processing.state = {
        x: 100, 
        y: 100, 
        direction:"", 
        snake: mySnake,
        lifes: myLifes,
        snakeLifes: 3,
        ovniLives:10,
        ovni: myOvni,
        inverse: false,
        ovniDirection: 10, //guarda +10 o -10 para que el ovni avance o retroceda en el eje x, inicia en 10 para que entre.
        food:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10), width:10, height:10, r: 210, g:210, b:100, existance:false},
        watermelon:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10),width:10,height:10,existance:false},
        avocado:{x:800, y: 800,width:10,height:10},
        rottenAvocado:{x:800, y: 800,width:10,height:10},
        shooting:false,
        shootingDirection:"", //guarda la dirección que tenía el snake al momento de disparar para rotar la imagen de la bala en rotateImg
        ammo:{amount:99999, x:0, y:0, size:10, speed:25},
        bullets:{amount:  0, x:0, y:0, size:10, speed:20},
        score:0,
        fixed:{},
        fixedSnake: {},
        inOvni:true,
        closeCanvas: {border: [] },
        shootingOvni:false,
        isNodding:false,
        sound: new buzz.sound("web-lib/s2",{formats: ["mp3"],autoplay: true,preload: true, volume: 50}),
        soundVida: new buzz.sound("web-lib/vida",{formats: ["mp3"],autoplay: false,preload: true, volume: 100}),
        soundLaser: new buzz.sound("web-lib/disparo laser",{formats: ["mp3"],autoplay: false,preload: true, volume: 80}),
        soundBattle: new buzz.sound("web-lib/batalla",{formats: ["mp3"],autoplay: false,preload: true, volume: 60}),

        };

        boss = processing.loadImage("img/OVNI_BOSS.png");
        apple = processing.loadImage("img/apple.png");
        wMelon = processing.loadImage("img/watermelon.png");
        aguacate = processing.loadImage("img/aguacate.png");
        heart = processing.loadImage("img/heart.png");
        skin = processing.loadImage("img/skin.PNG");
        back = processing.loadImage("img/back.gif");
        balaOvni = processing.loadImage("img/ammo.png");
        balaSnakeH = processing.loadImage("img/venoH.png");
        balaSnakeV = processing.loadImage("img/venoV.png");
        asteroid = processing.loadImage("img/asteroid.png"); //falta pintarlo
        barrier = processing.loadImage("img/obstaculos.png"); // falta pintarlo

        var canvas = document.getElementById("canvas").focus();
    }
    // funcion que retorna la posición de la imágen de la bala del snake dependiendo de su posición
    //devuelve true si se debe utilizar la vertical
    //debuelte false si se debe utilizar la horizontal
    function rotateImg(world){
        if(world.shootingDirection == "UP" || world.shootingDirection == "DOWN"){
          return true;
        }else if(world.shootingDirection == "LEFT" || world.shootingDirection == "RIGHT"){
          return false;
        }
       }

    /*Detiene el juego si la cabeza se estrella con el cuerpo del snake.
      Detiene el juego si la cabeza del snake se estrella con el ovni
    Retorna false si no se está chocando y true en caso contrario.
    */
    
    function crashBody(body,head,world){
        if(isEmpty(body)) {
          return false;
        }// Condición si la cabeza se estrella con el ovni
        else if(head.x == first(body).x && head.y == first(body).y || 
        head.x >= world.ovni.body[0].x && head.x <= world.ovni.body[0].x + 70 &&
        head.y >= world.ovni.body[0].y && head.y <= world.ovni.body[0].y + 60) {
          return true;
        }if(world.score >= score1 && (head.x >= 490 || head.x <= 10 || head.y >= 490 || head.y <= 0)){
            return true;
          }else if(distance(world.ammo.x,world.ammo.y,world.snake[0].x,world.snake[0].y) < 20 ||
          distance(world.ammo.x,world.ammo.y,world.snake[0].x,world.snake[1].y) < 20 ||
          distance(world.ammo.x,world.ammo.y,world.snake[0].x,world.snake[2].y) < 20 || 
          distance(world.ammo.x,world.ammo.y,world.snake[0].x,world.snake[3].y) < 20){
            return true;
          }
        else {
          return crashBody(rest(body),head,world);
        }
            
      }



      
      //Hace aparecer al snake por el otro lado del juego
      function reAppear(world,positionx,positiony){
        return make(world,{snake:cons({x:first(world.snake).x+positionx,y:first(world.snake).y+positiony},pop(world.snake)),
       // ovni:make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body))})
      });
      }
      
    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo estado del mundo
    */
    
    processing.onTic = function (world) {
      
        //Crashbody revisa que no se esté chocando                  
        if(crashBody(rest(world.snake),first(world.snake),world)==false){
          
            switch (world.direction) {
            case "UP":
            if(first(world.snake).y==0) {
              return reAppear(world,0,gameSize.height);
            }
              return master(world,0,-10,(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10));
            break;
            case "DOWN":
            if(first(world.snake).y==gameSize.height) {
              return reAppear(world,0,-gameSize.height);
            }
            return master(world,0,10,(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10));
            break;
            case "LEFT":
            if(first(world.snake).x==0) {
              return reAppear(world,gameSize.width,0);
            }
            return master(world,-10,0,(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10));
            break;
            case "RIGHT":
            if(first(world.snake).x==gameSize.width) {
              return reAppear(world,-gameSize.width,0);
            }
            return master(world,10,0,(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10),(Math.floor(processing.random(1,48))*10));
            break;
            default:
            return make(world,{});
          }
           
          
        } else{ //Esto ocurre cuando el snake choca con su propio cuerpo o con el ovni
          return make(world,{
        x: 100, 
        y: 100, 
        snake: mySnake,
        ovni: myOvni,
        snakeLifes: world.snakeLifes -1,
        food:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10), width:10, height:10,existance:false},
        watermelon:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10),width:10,height:10,existance:false},
        avocado:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10),width:10,height:10},
        rottenAvocado:{x:(Math.floor(processing.random(1,48))*10), y: (Math.floor(processing.random(1,48))*10),width:10,height:10},
        score:0,
        shooting: false,
        shootingOvni: false,
        closeCanvas: {border: [] },
        direction: "", 
        });
        }
    }
 
    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch (keyCode) {
        case processing.UP:
        if(world.inverse == true){
           if(world.direction == "RIGHT" || world.direction == "LEFT"){
             return make(world,{direction: "DOWN"})
           }
        }
        if(world.direction=="DOWN") {
          return make(world, {direction:"DOWN"})
        }
          return make(world,{direction: "UP"})
          break;

        case processing.DOWN:
        if(world.inverse == true){
           if(world.direction == "RIGHT" || world.direction == "LEFT"){
             return make(world,{direction: "UP"})
           }
        }
        if(world.direction=="UP") {
          return make(world, {direction:"UP"})
        }
          return make(world, { direction: "DOWN" });
          break;

        case processing.LEFT:
        if(world.inverse == true){
           if(world.direction == "UP" || world.direction == "DOWN"){
             return make(world,{direction: "RIGHT"})
           }
        }
        if(world.direction=="RIGHT") {
          return make(world, {direction:"RIGHT"})
        }
          return make(world, { direction: "LEFT"});
          break;
        case processing.RIGHT:
        if(world.inverse == true){
           if(world.direction == "UP" || world.direction == "DOWN"){
             return make(world,{direction: "LEFT"})
           }
        }
        if(world.direction=="LEFT") {
          return make(world, {direction:"LEFT"})
        }
          return make(world, { direction: "RIGHT" });
          break;
        //Barra espaciadora para disparar  
        case 32: //PENDIENTE POR OPTIMIZAR
        if(world.bullets.amount > 0 && !world.shooting){
          world.soundLaser.play();
          /*Si hay al menos una bala, cambia su estado a true, disminuye en 1 
        la cantidad de balas y guarda en fixed la dirección que debe conservar la bala.*/
          switch(world.direction) {
            
            case "UP":
            return make(world, {shooting:true,
            shootingDirection: "UP",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:0,y:-world.bullets.speed})});
            break;
            case "DOWN":
            return make(world, {shooting:true,
            shootingDirection: "DOWN",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:0,y:world.bullets.speed})});
            break;
            case "RIGHT":
            return make(world, {shooting:true,
            shootingDirection: "RIGHT",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:world.bullets.speed,y:0})});
            break;
            case "LEFT":
            return make(world, {shooting:true,
            shootingDirection: "LEFT",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:-world.bullets.speed,y:0})});
            break;
            default:
            return make(world,{});
          }
          
          //console.log(world.bullets.amount)
        } else{
          return make(world,{});
        }    
        break;
        default:
      
          return make(world, {});
      }
      
    }
    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world) {
      processing.textFont(processing.createFont("Retro Gaming"))
      world.sound.play();

    function drawWin(world){
      if(world.ovniLives == 0){
        processing.background(0,0,0);
        processing.textSize(50,50)
        processing.textAlign(processing.CENTER,processing.TOP);
        processing.text("YOU WIN!",250,250)
      }else if(world.snakeLifes == 0){
        processing.background(0,0,0);
        processing.textSize(50,50)
        processing.textAlign(processing.CENTER,processing.TOP);
        processing.text("YOU LOSE!",250,250)
      }else {



      function backGround(world) {
          processing.image(back,0,0,500,500);
        }
      backGround(world);
      //Pinta el score sencillo
      processing.text("SNAKE LIVES: " +world.snakeLifes, 20, 40);
      processing.text("SNAKE BULLETS: " +world.bullets.amount, 20, 20);
      processing.text("SCORE: " +world.score, 400, 480);

      //Pinta los ammo sencillo
      if(world.score >= score1){
      processing.text("BOSS LIVES: " +world.ovniLives, 380, 20);

      }
     // processing.text("AMMO: "+world.ammo.x + " " + world.ammo.y, 20, 80);
     // processing.text("K: "+world.k, 20, 100);
      //Dibuja únicamente el cuerpo del snake
      function drawSnake(snake) {
        snake.forEach(part => {
          processing.image(skin,part.x + nodding(part.y, world), part.y + nodding(part.x, world), size,size);
        })
      }
      drawSnake(rest(world.snake));
      //Dibuja únicamente la cabeza del snake
      function drawSnakeHead(head) {

        processing.image(skin,head.x + nodding(head.y, world), head.y + nodding(head.x, world), size, size);
      }
      drawSnakeHead(world.snake[0]);

      //Dibuja las balas del snake

      function drawBullets(world,bullets) {
        if(world.shooting == true && rotateImg(world)==true){

          processing.image(balaSnakeV,bullets.x,bullets.y,bullets.size+10,bullets.size+10)
        }else if(world.shooting == true && rotateImg(world) == false){

           processing.image(balaSnakeH,bullets.x,bullets.y,bullets.size+10,bullets.size+10)
        }
      }
      drawBullets(world, world.bullets);

      //Dibuja las balas del ovni
      function drawAmmoC(world,ammo) {
        if(world.shootingOvni==true) { //
          processing.image(balaOvni,ammo.x, ammo.y, ammo.size+10, ammo.size+10);
        }
      }
      drawAmmoC(world, world.ammo);
      //Dibuja la comida

      function drawFood(food) {
        if(food.existance==false) {
          processing.image(apple,food.x, food.y, food.width+10, food.height+10);
    
        }
      }
      drawFood(world.food);
      //Dibujaría las sandías
      function drawWatermelons(watermelon) {
        if(watermelon.existance==false){
          processing.image(wMelon,watermelon.x, watermelon.y, watermelon.width+10, watermelon.height+10);
        }
      }
      drawWatermelons(world.watermelon);
      
      //Dibuja los aguacates buenos
      function drawAvocado(avocado) {
        if(world.snakeLifes<3){
          processing.image(aguacate,world.avocado.x, world.avocado.y, avocado.width+ 10, avocado.height+ 10);
        }
      }
      drawAvocado(world.avocado);

      //Dibuja los aguacates malos
        function drawRottenAvocado(rottenAvocado) {
        if(world.snakeLifes<3){
          processing.image(aguacate,world.rottenAvocado.x, world.rottenAvocado.y, rottenAvocado.width+ 10, rottenAvocado.height+ 10);
        }
      }
      drawRottenAvocado(world.rottenAvocado);


      function drawOvni(ovni) {
        ovni.body.forEach(part => { //En caso de quitar la lista hay que cambiar esto
          processing.image(boss,part.x, part.y, size*8,size*8);
        })
      }
      drawOvni(world.ovni)

      function drawLifes(lifes) {
          if(world.snakeLifes >= 3){
              lifes.forEach(part => { 
                 processing.image(heart,part.x, part.y, size*3,size*3);
              })
          }if(world.snakeLifes == 2){
            pop(lifes).forEach(part => { 
                 processing.image(heart,part.x, part.y, size*3,size*3);
              })
          }if(world.snakeLifes == 1){
                 processing.image(heart,world.lifes[0].x, world.lifes[0].y, size*3,size*3);
              }
          }
      drawLifes(world.lifes);

      function drawBorders(world)
      { if(world.score >= score1){
        world.closeCanvas.border.forEach(part => {
          
          processing.image(barrier,part.x,part.y,10,10)  
        })
      }
    }

      function setBorders(closeCanvas)
      {
        closeCanvas.border=[{x: 490,y: 240,size:1},{x: 490,y: 230,size:2}];
      }

      function buildBorders(closeCanvas)
      {
        if (closeCanvas.border[0].x!=pop(closeCanvas.border).x && closeCanvas.border[0].y!=pop(closeCanvas.border).y)
        {
          
          if(closeCanvas.border[0].x==490 && closeCanvas.border[0].y > 0 && closeCanvas.border[0].y<250)
          {
            closeCanvas.border=cons({x: closeCanvas.border[0].x, y: closeCanvas.border[0].y-10,size: closeCanvas.border[0].size+1},closeCanvas.border);
          }
          else if(closeCanvas.border[0].x>0 && closeCanvas.border[0].y == 0)
          {
            closeCanvas.border=cons({x: closeCanvas.border[0].x-10, y: closeCanvas.border[0].y,size: closeCanvas.border[0].size+1},closeCanvas.border);
          }
          else if(closeCanvas.border[0].x==0&&closeCanvas.border[0].y<490)
          {
            closeCanvas.border=cons({x: closeCanvas.border[0].x, y: closeCanvas.border[0].y+10,size: closeCanvas.border[0].size+1},closeCanvas.border);
          }
          else if(closeCanvas.border[0].x<490&&closeCanvas.border[0].y==490)
          {
            closeCanvas.border=cons({x: closeCanvas.border[0].x+10, y: closeCanvas.border[0].y,size: closeCanvas.border[0].size+1},closeCanvas.border);
          }
          else if(closeCanvas.border[0].x==490&&closeCanvas.border[0].y>249)
          {
            closeCanvas.border=cons({x: closeCanvas.border[0].x, y: closeCanvas.border[0].y-10,size: closeCanvas.border[0].size+1},closeCanvas.border);
          }
        }
        
      }
      if (length(world.closeCanvas.border)<2)
      {
        setBorders(world.closeCanvas);
      }
      if(length(world.closeCanvas.border)<197)
      {
      if(world.score >= score1){
        buildBorders(world.closeCanvas);
      }
    } 
      
      drawBorders(world);
      }
    }
    drawWin(world);
      
    };

    
    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state);
      processing.state = processing.onTic(processing.state);
    };
    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
    }
  }
  var canvas = document.getElementById("canvas");
  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>
