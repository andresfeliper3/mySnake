<canvas id="canvas" width="500" height="500"></canvas>
<script src="web-lib/processing.js"></script>
<script src="web-lib/functional-light.js"></script>
<script>
  //Vamos a usar http://processingjs.org/

let x= 0;
  // Importamos las librerias
  let { append, cons, first, isEmpty, isList, length, rest } = functionalLight;
  function make(data, attribute) {
    return Object.assign({}, data, attribute);
  } 
  //FUNCIONES
  /*pop:list->list
Quita el último elemento de una lista
pop([1,2,3])->[1,2]
pop([4,0,5,9,7])->[4,0,5,9]
*/
function pop(list) {
    if(length(list)==1) {
        return [];
    } else {
        return cons(first(list),pop(rest(list)));
    }
}
//DIspara mientras mantiene el movimiento
function shootSnake(world, ax, ay) {
 if((world.bullets.x <= 500 && world.bullets.x >=0) && (world.bullets.y <=500 && world.bullets.y >= 0)) {
         return make(world,{bullets:make(world.bullets,{
          x:world.bullets.x + world.fixedSnake.x,
          y:world.bullets.y + world.fixedSnake.y
        }),
         snake:cons({x: world.snake[0].x + ax , y: world.snake[0].y + ay},pop(world.snake)),
         ammo:make(world.ammo,{
           x:world.ammo.x + world.fixed.x,
           y:world.ammo.y + world.fixed.y
         }),
        ovni:make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body)),
                                                                 
        })
         });
  } else {
    return make(world,{shooting:false,
      bullets:make(world.bullets,{x:world.snake[0].x, y:world.snake[0].y}),
      ovni:make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body)),
                                                                 
        })
    
    });
  }
}

/*movement
Hace que el snake se mueva únicamente (sin crecer).
*/
function movement(world,ax,ay) {
  console.log("move")
     return make(world,{ammo:make(world.ammo,{x:world.ovni.body[0].x + ax, y:world.ovni.body[0].y + ay}),
          snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake)),
          k: kValue(world),
          bullets:make(world.bullets,{x:first(world.snake).x + ax, y:first(world.snake).y + ay}),
         // fixed: make(world.fixed,{x:0,y:-world.ammo.speed})       
        });
    
  
}
    /*Reposiciona la comida, aumenta el score y hace que el snake crezca en 1*/
    function eating(world,ax,ay,randomx,randomy) {
  return make(world,{food:make(world.food,{x:randomx, y: randomy}),
  snake:cons({x: first(world.snake).x + ax, y: first(world.snake).y + ay},world.snake),
  score:world.score+score1});
  
}
/*Reposiciona las sandías y aumenta los ammo */
function eatingWatermelon(world, ax, ay,randomx,randomy){
  return make(world,{watermelon:make(world.watermelon,{x:randomx, y: randomy}),
  snake:cons({x: first(world.snake).x + ax, y: first(world.snake).y + ay}, pop(world.snake)),
  bullets:make(world.bullets,{amount:world.bullets.amount + 1}),
  ammo:make(world.ammo,{amount:world.ammo.amount + 1})
  });
}

/*master
Evalúa condiciones para establecer los cambios y el comportamiento en el mundo
*/
function master(world,ax,ay,randomx,randomy) {
  //Acción de comer
  if(first(world.snake).x==world.food.x && first(world.snake).y==world.food.y) {
    return eating(world,ax,ay,randomx,randomy);
    //Acción de comer sandías
   } else if(first(world.snake).x==world.watermelon.x && first(world.snake).y==world.watermelon.y){
    return eatingWatermelon(world,ax,ay,randomx,randomy);
  
   }//Acción de reconocer cuando el snake pasa en el rango de disparo del ovni
   else if(world.snake[0].x + world.k == world.ovni.body[0].x){
     console.log("reconocimiento")
      return ia(world,ax,ay)
   } //Acción de disparar del snake
   else if(world.shooting) {
      return shootSnake(world,ax,ay);
      
   }else if(world.shootingOvni){ // 
   //Acción de disparo del ovni
    return shootOvni(world,ax,ay);
   }
   else if(world.score >= 100){ //condición para que el score supere cierto puntaje
    //movimiento constante del ovni
    return moveOvni(world,ax,ay);
   }else {
      //Movimiento
        return movement(world,ax,ay);
  }
}


//retorna true si el snake está arriba y false si el snake está abajo del helicóptero
function positionUp(world){
  if(world.snake[0].y <= 250){
    return true;
  }else{
    return false;
  }
}
// funcion que retorna el valor de K, k es una constante que determina la predicción del disparo del helicóptero
//Es la distancia respecto a x, a la cual debe estar el snake del helicóptero para que dispara
function kValue(world){
  switch (world.direction){
    case "UP":
        return 0
        break;
      
    case "DOWN":
        return 0
        break;
    case "RIGHT":
        return 20
        break;
    case "LEFT":
        return -20
        break;
        default:
      return 0
  }
}
 
//Controla los disparos del ovni, se ejecuta cuando shootingOvni es true
function shootOvni(world,ax,ay) {
  console.log("shootOvni")
  //Si las balas están en el canvas, las mueve, si no, las reposiciona en el ovni
  if((world.ammo.x <= 500 && world.ammo.x >=0) && (world.ammo.y <=500 && world.ammo.y >= 0)) {
         return make(world,{ammo:make(world.ammo,{
          x:world.ammo.x + world.fixed.x,
          y:world.ammo.y + world.fixed.y
        }),
         snake:cons({x: world.snake[0].x + ax , y: world.snake[0].y + ay},pop(world.snake)),
         
         });
  } else {
    return make(world,{shootingOvni:false,
      ammo:make(world.ammo,{x:world.ovni.body[0].x, y:world.ovni.body[0].y})});
  }
}
//Reconocimiento de la posición del snake para iniciar el disparo
function ia(world,ax,ay){
  console.log("ia")
  //Si el snake está sobre el eje x del ovni
  if(positionUp(world)== true){
        return make(world,{shootingOvni:true,
          fixed: make(world.fixed,{x:0,y:-world.ammo.speed}),//Guarda la dirección del disparo, es decir hacia arriba
         // ammo:make(world.ammo,{x:world.ovni.body[0].x + ax, y:world.ovni.body[0].y -20}),
          snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake)),
         
          bullets:make(world.bullets,{x:first(world.snake).x + ax, y:first(world.snake).y + ay})});
    
  }else{
    return make(world,{shootingOvni:true,
          fixed: make(world.fixed,{x:0,y:world.ammo.speed}), //Guarda la dirección del disparo, es decir hacia abajo
       //   ammo:make(world.ammo,{x:world.ovni.body[0].x + ax, y:world.ovni.body[0].y + 20}),
          snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake)),
          
          bullets:make(world.bullets,{x:first(world.snake).x + ax, y:first(world.snake).y + ay})});
  }
}
// Controla el movimiento del OVNI(ovni). Al llegar a las coordenadas límite, se crea el efecto de rebote
function moveOvni(world,ax,ay){ 
    //Revisa si el ovni ha llegado a la coordenada final
   if(world.ovni.body[0].x == 420) {
    return make(world,{ ovni: make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body)),
                                                                   // wings: [make(world.ovni.wings[0],{x: world.ovni.body[0].x}),make(world.ovni.wings[1],{x: world.ovni.body[0].x})]
                                                                  }),
                                                                    snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake)),
                                                                    ovniDirection: -10});
  }else if (world.ovni.body[0].x == 0){

     return make(world,{ ovni: make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body)),
                                                                  //  wings: [make(world.ovni.wings[0],{x: world.ovni.body[0].x}),make(world.ovni.wings[1],{x: world.ovni.body[0].x})]
                                                                  })
                                                                    ,snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake)),
                                                                    ovniDirection: 10});
    }else{
      
      return make(world,{ ovni: make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body)),
                                                                 
                         }),
                          ammo:make(world.ammo,{x:world.ovni.body[0].x + ax, y:world.ovni.body[0].y + ay}),
                          k: kValue(world),
                          bullets:make(world.bullets,{x:first(world.snake).x + ax, y:first(world.snake).y + ay}),
                          snake:cons({x: first(world.snake).x + ax , y: first(world.snake).y + ay},pop(world.snake))})
  }
}
  //Dimensiones del juego
  const gameSize = {height:500,width:500};
  //Tamaño de cada segmento del snake
  const size = 10;
  //Aumento del score al comer
  const score1 = 100; 
  const mySnake = [{ x: 100, y: 100 }, { x: 90, y: 100 }, { x: 80, y: 100 },{ x:70, y:100}];

  const myOvni = {body: [{x:-100,y:250}],
                   // wings:[{x:-10,y:240},{x:-10,y:260}]
                  }
  function sketchProc(processing) {
    /**
     * Esto se llama antes de iniciar el juego
     */
    processing.setup = function () {
      processing.frameRate(10);
      processing.size(gameSize.width, gameSize.height);
      processing.background(0, 0, 0);
      processing.state = {
        x: 100, 
        y: 100, 
        direction:"", 
        snake: mySnake,
        ovni: myOvni,
        ovniDirection: 10, //guarda +10 o -10 para que el ovni avance o retroceda en el eje x, inicia en 10 para que entre.
        food:{x:(Math.floor(processing.random(1,50))*10), y: (Math.floor(processing.random(1,50))*10), width:10, height:10, r: 210, g:210, b:100, existance:false},
        watermelon:{x:(Math.floor(processing.random(1,50))*10), y: (Math.floor(processing.random(1,50))*10),width:10,height:10,existance:false},
        shooting:false,
        shootingDirection:"", //guarda la dirección que tenía el snake al momento de disparar para rotar la imagen de la bala en rotateImg
        ammo:{amount:99999, x:0, y:0, size:10, speed:20},
        bullets:{amount: 0, x:0, y:0, size:10, speed:20},
        score:0,
        fixed:{},
        fixedSnake: {},
        inOvni:true,
        k: 0,
        shootingOvni:false
        };

        boss = processing.loadImage("img/OVNI_BOSS.png");
        apple = processing.loadImage("img/apple.png");
        wMelon = processing.loadImage("img/watermelon.png");
        heart = processing.loadImage("img/heart.png");
        noHeart = processing.loadImage("img/noHeart.png");
        skin = processing.loadImage("img/skin.png");
        back = processing.loadImage("img/back.gif");
        balaOvni = processing.loadImage("img/ammo.png");
        balaSnakeH = processing.loadImage("img/venoH.png");
        balaSnakeV = processing.loadImage("img/venoV.png");

        var canvas = document.getElementById("canvas").focus();
    }
    // funcion que retorna la posición de la imágen de la bala del snake dependiendo de su posición
    //devuelve true si se debe utilizar la vertical
    //debuelte false si se debe utilizar la horizontal
    function rotateImg(world){
        if(world.shootingDirection == "UP" || world.shootingDirection == "DOWN"){
          return true;
        }else if(world.shootingDirection == "LEFT" || world.shootingDirection == "RIGHT"){
          return false;
        }
       }

    /*Detiene el juego si la cabeza se estrella con el cuerpo del snake.
    Retorna false si no se está chocando y true en caso contrario.
    */
    
    function crashBody(body,head,world){
        if(isEmpty(body)) {
          return false;
        } else if(head.x == first(body).x && head.y == first(body).y) {
        
          return true;
        } 
        else {
          return crashBody(rest(body),head,world);
        }
            
      }
      //Hace aparecer al snake por el otro lado del juego
      function reAppear(world,positionx,positiony){
        return make(world,{snake:cons({x:first(world.snake).x+positionx,y:first(world.snake).y+positiony},pop(world.snake)),
        ovni:make(world.ovni,{body: cons({x:first(world.ovni.body).x+world.ovniDirection,y:first(world.ovni.body).y},pop(world.ovni.body))})
      });
      }
      
    /**
    * Actualiza el mundo en cada tic del reloj. Retorna el nuevo estado del mundo
    */
    
    processing.onTic = function (world) {
      
        //Crashbody revisa que no se esté chocando                  
        if(crashBody(rest(world.snake),first(world.snake),world)==false){
          
            switch (world.direction) {
            case "UP":
            if(first(world.snake).y==0) {
              return reAppear(world,0,gameSize.height);
            }
              return master(world,0,-10,(Math.floor(processing.random(1,50))*10),(Math.floor(processing.random(1,50))*10));
            break;
            case "DOWN":
            if(first(world.snake).y==gameSize.height) {
              return reAppear(world,0,-gameSize.height);
            }
            return master(world,0,10,(Math.floor(processing.random(1,50))*10),(Math.floor(processing.random(1,50))*10));
            break;
            case "LEFT":
            if(first(world.snake).x==0) {
              return reAppear(world,gameSize.width,0);
            }
            return master(world,-10,0,(Math.floor(processing.random(1,50))*10),(Math.floor(processing.random(1,50))*10));
            break;
            case "RIGHT":
            if(first(world.snake).x==gameSize.width) {
              return reAppear(world,-gameSize.width,0);
            }
            return master(world,10,0,(Math.floor(processing.random(1,50))*10),(Math.floor(processing.random(1,50))*10));
            break;
            default:
            return make(world,{});
          }
           
          
        } else{ //Esto ocurre cuando el snake choca con su propio cuerpo
          return make(world,{
        x: 100, 
        y: 100, 
        direction:"", 
        snake: mySnake,
        food:{x:(Math.floor(processing.random(1,50))*10), y: (Math.floor(processing.random(1,50))*10), width:10, height:10, r: 210, g:210, b:100, existance:false},
        watermelon:{x:(Math.floor(processing.random(1,50))*10), y: (Math.floor(processing.random(1,50))*10),width:10,height:10,existance:false}, 
        score:0 
        });
        }
    }
 
    /**
    * Actualiza el mundo cada vez que se oprime una tecla. Retorna el nuevo stado del mundo
    */
    processing.onKeyEvent = function (world, keyCode) {
      switch (keyCode) {
        case processing.UP:
        if(world.direction=="DOWN") {
          return make(world, {direction:"DOWN"})
        }
          return make(world,{direction: "UP"})
          break;
        case processing.DOWN:
        if(world.direction=="UP") {
          return make(world, {direction:"UP"})
        }
          return make(world, { direction: "DOWN" });
          break;
        case processing.LEFT:
        if(world.direction=="RIGHT") {
          return make(world, {direction:"RIGHT"})
        }
          return make(world, { direction: "LEFT"});
          break;
        case processing.RIGHT:
        if(world.direction=="LEFT") {
          return make(world, {direction:"LEFT"})
        }
          return make(world, { direction: "RIGHT" });
          break;
        //Barra espaciadora para disparar  
        case 32: //PENDIENTE POR OPTIMIZAR
        if(world.bullets.amount > 0 && !world.shooting){
          /*Si hay al menos una bala, cambia su estado a true, disminuye en 1 
        la cantidad de balas y guarda en fixed la dirección que debe conservar la bala.*/
          switch(world.direction) {
            case "UP":
            return make(world, {shooting:true,
            shootingDirection: "UP",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:0,y:-world.bullets.speed})});
            break;
            case "DOWN":
            return make(world, {shooting:true,
            shootingDirection: "DOWN",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:0,y:world.bullets.speed})});
            break;
            case "RIGHT":
            return make(world, {shooting:true,
            shootingDirection: "RIGHT",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:world.bullets.speed,y:0})});
            break;
            case "LEFT":
            return make(world, {shooting:true,
            shootingDirection: "LEFT",
            bullets:make(world.bullets,{amount:world.bullets.amount - 1}),
            fixedSnake:make(world.fixedSnake,{x:-world.bullets.speed,y:0})});
            break;
            default:
            return make(world,{});
          }
          
          //console.log(world.bullets.amount)
        } else{
          return make(world,{});
        }    
        break;
        default:
      
          return make(world, {});
      }
      
    }
    // Dibuja algo en el canvas. Aqui se pone todo lo que quieras pintar
    processing.drawGame = function (world) {
      //processing.background(0,0,0);

      function backGround(world) {
          processing.image(back,0,0,500,500);
        }
      backGround(world);
      //Pinta el score sencillo 
      processing.text("shooting: "+ world.shooting, 20, 20);
      //Pinta los ammo sencillo
      processing.text("BALAS: "+ world.bullets.amount, 20, 40);
      processing.text("shootingOvni: " +world.shootingOvni, 20, 60);
      processing.text("FIXED : "+world.fixed.x + " " + world.fixed.y, 20, 80);
     // processing.text("AMMO: "+world.ammo.x + " " + world.ammo.y, 20, 80);
     // processing.text("K: "+world.k, 20, 100);
      //Dibuja únicamente el cuerpo del snake
      function drawSnake(snake) {
        snake.forEach(part => {
          processing.image(skin,part.x, part.y, size,size);
        })
      }
      drawSnake(rest(world.snake));
      //Dibuja únicamente la cabeza del snake
      function drawSnakeHead(head) {
        processing.fill(250,250,250);
        processing.rect(head.x, head.y, size, size);
      }
      drawSnakeHead(world.snake[0]);

      //Dibuja las balas del snake

      function drawBullets(world,bullets) {
        if(world.shooting == true && rotateImg(world)==true){

          processing.image(balaSnakeV,bullets.x,bullets.y,bullets.size+10,bullets.size+10)
        }else if(world.shooting == true && rotateImg(world) == false){

           processing.image(balaSnakeH,bullets.x,bullets.y,bullets.size+10,bullets.size+10)
        }
      }
      drawBullets(world, world.bullets);
      //Dibuja las balas del ovni
      function drawAmmoC(world,ammo) {
        if(world.shootingOvni==true) { //
          processing.image(balaOvni,ammo.x, ammo.y, ammo.size+10, ammo.size+10);
        }
      }
      drawAmmoC(world, world.ammo);
      //Dibuja la comida

      function drawFood(food) {
        if(food.existance==false) {
          processing.image(apple,food.x, food.y, food.width+15, food.height+15);
    
        }
      }
      drawFood(world.food);
      //Dibujaría las sandías
      function drawWatermelons(watermelon) {
        if(watermelon.existance==false){
          processing.image(wMelon,watermelon.x, watermelon.y, watermelon.width+15, watermelon.height+15);
        }
      }
      drawWatermelons(world.watermelon);

      function drawOvni(ovni) {
        ovni.body.forEach(part => {
          processing.image(boss,part.x, part.y, size*8,size*8);
        })
      }
      drawOvni(world.ovni)
    }
    // Esta es la función que pinta todo. Se ejecuta 60 veces por segundo. 
    // No cambie esta función. Su código debe ir en drawGame
    processing.draw = function () {
      processing.drawGame(processing.state);
      processing.state = processing.onTic(processing.state);
    };
    // Esta función se ejecuta cada vez que presionamos una tecla. 
    // No cambie esta función. Su código debe ir en onKeyEvent
    processing.keyPressed = function () {
      processing.state = processing.onKeyEvent(processing.state, processing.keyCode);
    }
  }
  var canvas = document.getElementById("canvas");
  // Adjuntamos nuestro sketch al framework de processing
  var processingInstance = new Processing(canvas, sketchProc);
</script>
